<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python-mianshi]]></title>
    <url>%2F2018%2F06%2F15%2Fpython-mianshi%2F</url>
    <content type="text"><![CDATA[Python是如何进行内存管理的Answer：从三个方面来说：对象的引用计数机制 垃圾回收机制 内存池机制 引用计数：每一个对象负责维护对象所有引用的计数值。当一个新的引用指向对象时，引用计数器就递增，当去掉一个引用时，引用计数就递减。当引用计数到零时，该对象就将释放占有的资源。 对象的引用计数机制 Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。 引用计数增加的情况 对象被分配一个新的别名：y = x 对象被放入一个容器中(比如列表、元组、字典) 引用计数减少的情况 对象引用超出作用域 对象的一个别名被重新赋值 对象的别名被销毁del x mylist.remove(x) del mylist sys.getrefcount() 函数可以获得当前对象的引用计数。 垃圾回收机制 当一个对象的引用计数归零时，它将被垃圾回收机制处理掉。 当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用， 因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。 内存池机制 Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。 为了加速Python 的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 参考： 垃圾回收机制：https://www.cnblogs.com/Xjng/p/5128269.html 内存池机制： https://blog.csdn.net/alertbear/article/details/50808178 什么是lambda函数？它有什么优点？Answer： lanbda函数通常指匿名函数。 优点：需要一个函数，而且我们只会需要调用它一次，但是又不想费神去命名一个函数的场合下使用 Python里面如何拷贝一个对象？（赋值、浅拷贝、深拷贝的区别）Answer： 赋值（=）：就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到其它。 浅拷贝copy()：拷贝的是对象本身，对象内部的元素只是拷贝了一个引用。也就是，把对象复制一遍，但是该对象中引用的其他对象我不复制 12345678910111213import copya = [1,'str',[1,2,3]]b = copy.copy(a)print(b)&gt;&gt;&gt; [1,'str',[1,2,3]]print(id(a),id(b))&gt;&gt;&gt; 140202879296904 140202879395208b[0] = 5print(a,b)&gt;&gt;&gt; [1, 'str', [1, 2, 3]] [5, 'str', [1, 2, 3]]b[2][0] = 2print(a,b)&gt;&gt;&gt; [1, 'str', [2, 2, 3]] [5, 'str', [2, 2, 3]] 深拷贝deepcopy()：外围和内部元素都进行了拷贝对象本身，而不是引用。也就是，把对象复制一遍，并且该对象中引用的其他对象我也复制。 12345678910111213import copya = [1,'str',[1,2,3]]b = copy.deepcopy(a)print(b)&gt;&gt;&gt; [1,'str',[1,2,3]]print(id(a),id(b))&gt;&gt;&gt; 140202879296904 140202879395208b[0] = 5print(a,b)&gt;&gt;&gt; [1, 'str', [1, 2, 3]] [5, 'str', [1, 2, 3]]b[2][0] = 2print(a,b)&gt;&gt;&gt; [1, 'str', [1, 2, 3]] [5, 'str', [2, 2, 3]] ​ 1，深浅拷贝都是对源对象的复制，占用不同的内存空间。 2，不可变类型的对象，对于深浅拷贝毫无影响，最终的地址值和值都是相等的。 3，可变类型：=浅拷贝： 值相等，地址相等copy浅拷贝：值相等，地址不相等deepcopy深拷贝：值相等，地址不相等 except 的用法Answer：try…except…except…[else…][finally…] 执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。 如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。 try下的语句正常执行，则执行else块代码。 如果存在finally语句，不管异常引发与否，finally语句都会被执行。]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Django仿写V2EX（一）]]></title>
    <url>%2F2018%2F06%2F06%2Fdjango-v2ex-1%2F</url>
    <content type="text"><![CDATA[建立 Django 工程开发环境：Python3 + Django2 强烈建议在虚拟环境中进行 Django 开发。 最方便的方法是使用 PyChram 的创建项目功能，它可以创建一个 Django 项目，并且包含了一个安装了 Django 的虚拟环境。 你也可以在虚拟环境中手动使用 Django 命令行建立项目，如下：1django-admin startproject v2exproject 这个命令会生产一个 v2exproject 的项目文件夹。然后我们切换到项目文件夹内，执行1python manage.py runserver 如果没有出现报错，这样我们就启动了一个 Django Web 服务器。 一些设置Django 的默认语言是英语，但是它也提供了中文，我们可以在设置文件中更改。找到 v2exproject/settings.py 文件，修改：123456...# 语言设置LANGUAGE_CODE = 'en-us' # 值改为 "zh-hans"# 时区设置TIME_ZONE = 'UTC' # 值改为'Asia/Shanghai'... 保存后，刷新浏览器便可以看到中文的欢迎页面。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python web 框架之 Flask（一）]]></title>
    <url>%2F2018%2F06%2F05%2Fflask%2F</url>
    <content type="text"><![CDATA[前言 Flask 的思想是为所有应用建立一个良好的基础，其余的一切都取决于你和扩展。 Flask是一个微型框架，本身没有包含数据库层，也没有表单验证等其它方面的功能，FLask 的作用是建立 Werkezug 和 jinja2 之间的桥梁。除此之外的功能全部通过扩展等方式实现。 Werkzeug是一个WSGI工具包，他可以作为一个Web框架的底层库。 Jinja2 是一个 Python 的功能齐全的模板引擎。 Flask 对比 Django Flask Flask确实很“轻”，不愧是Micro Framework，从Django转向Flask的开发者一定会如此感慨，除非二者均为深入使用过 Flask自由、灵活，可扩展性强，第三方库的选择面广，开发时可以结合自己最喜欢用的轮子，也能结合最流行最强大的Python库 入门简单，即便没有多少web开发经验，也能很快做出网站 非常适用于小型网站 非常适用于开发web服务的API 开发大型网站无压力，但代码架构需要自己设计，开发成本取决于开发者的能力和经验 各方面性能均等于或优于Django Django自带的或第三方的好评如潮的功能，Flask上总会找到与之类似第三方库 Flask灵活开发，Python高手基本都会喜欢Flask，但对Django却可能褒贬不一 Flask与关系型数据库的配合使用不弱于Django，而其与NoSQL数据库的配合远远优于Django Flask比Django更加Pythonic，与Python的philosophy更加吻合 Django Django太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高 Django能开发小应用，但总会有“杀鸡焉用牛刀”的感觉 Django的自带ORM非常优秀，综合评价略高于SQLAlchemy Django自带的模板引擎简单好用，但其强大程度和综合评价略低于Jinja Django自带ORM也使Django与关系型数据库耦合度过高，如果想使用MongoDB等NoSQL数据，需要选取合适的第三方库，且总感觉Django+SQL才是天生一对的搭配，Django+NoSQL砍掉了Django的半壁江山 Django目前支持Jinja等非官方模板引擎 Django自带的数据库管理app好评如潮 Django非常适合企业级网站的开发：快速、靠谱、稳定 Django成熟、稳定、完善，但相比于Flask，Django的整体生态相对封闭 Django是Python web框架的先驱，用户多，第三方库最丰富，最好的Python库，如果不能直接用 Django中，也一定能找到与之对应的移植 Flask 快速入门建立一个 Flask 应用非常简单，像这样：123456789from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World!&apos;if __name__ == &apos;__main__&apos;: app.run() 使用解释器运行这个文件，便启动了一个web应用。 参考：https://blog.igevin.info/posts/flask-startup-guideline/http://docs.jinkan.org/docs/flask/index.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2018%2F06%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是这个博客的第一篇文章 以后我将会把一些文章发布在这里，欢迎围观 谢谢～]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
